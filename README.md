# Double-Dash-Scoring-System

Here is the game. My friend David and I play Mario Kart Double Dash on the Nintendo GameCube. We have a competition that involves playing all 16 tracks. However, we have a bit of a unique scoring system. First, we play the tracks in a random order. On the first track, the winner gets 1 point. On the next track, the winner gets 2 points. This pattern goes on all the way to the last track where the winner of the last race gets 16 points. The point value increases by 1 each race. Doing the calculations, there are 1+2+3...+16 = 16*17/2 = 136 total points possible. This means that both players could tie with 68 points or one player wins once they achieve 69 points or greater. David and I do this competition about every year and we think we are evenly matched.


The question we had that sparked me to do this project is "What is the probability that we tie assuming we are evenly matched?" For this, we need to know the amount of ways to add any combination of numbers 1,...,16 with no repeats to get 68 and then divide that by 2^16. For example, if one were to win races 1, 3, 4, 8, 10, 13, 14, and 15, each player would have 16 points resulting in a tie. However, finding every combination of that happening is too difficult of a problem. Therefore, I figured out a way to do it with code. 


My solution is a bit brute force, but it works. I essentially kept an array of every possible outcome. So if there are 16 races, the array will consist of 2^16 (65536) entries. We can do this because we can treat each race as binary since either one of two players win. So we can do a loop from 0 to 65535 and convert each number to binary. This represents the number of games the player of interest won. For example, 9495 translates to 0010010100010111. This means that the player of interest won games 3, 6, 8, 12, 14, 15, 16 which translates to 74 points. If the probability of winning is .5, then the probability of this outcome is 2^-16. However, if the probability of winning each race is .6, then the probability of this event is .6^7 * .4^9. I do this for every number between 0 and 65535. Then I loop through the list of outcomes and add the probability if it is equal to 68. By doing it this way, I can repeat this for any probability that I give a player to win each race. With this, I have determined that assuming we are evenly matched, the probability of a tie is ~2%. If I had a 55% chance to win each game, the probability of tying would be ~1.89%. I further extended this to find the probability that a player wins or loses as well. In the example of having a 55% chance of winning each race, the probability of winning the entire competition without a tie is ~62.87%. 


I programmed this in a robust way meaning that I could do this experiment for any number of races. For example, suppose I wanted to do this for 8 races. Then I could input 8 races and do the same process. I also made it so that you could input any scoring system. For example, let's say you have some weird point system where you have 9 races, but every third race counts for 3 points instead of 1. Then the probability of either player winning or tying can be computed. 


I also have the probability of reaching a certain score. For example, the probability of reaching 80 points assuming we are evenly matched is ~28.09%. One last feature that I'd like to add when I get the chance is make a list of probabilities for each track. Since there are some tracks that favor my skillset and some tracks that favor David's skillset. Instead of assuming .55 for each track, it is could be .75 for one track, then .4 for another track and so on. I could input a list of probabilities for each track. It doesn't matter the order of the probabilities since they will be shuffled to match the way the track order is shuffled. This would be easy to implement, but super tedious due to having to shift tons of things around in order for the function to also be able to take in another array.


Overall, this gives an exact solution... but there is a problem. Since we are considering every possible outcome and there are 2^N outcomes. This comes out to O(2^N) in space and in time which is extremely slow. Since the maximum number of integers in Java is 2147483647, we cannot exceed 2^30 which means N = 30 is the maximum this program can handle. It also takes an extremely long time to run beyond N = 24. The only thing I can think of is to make a second array to extend the first one. I know I could do it, but it would take a ton of work to shift things around to make it work.
